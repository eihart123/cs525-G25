/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Chars } from "./chars.js";
import { Style } from "./style.js";
function* tokenize(text) {
  for (let pos = 0; pos < text.length; ) {
    const unit = text[pos];
    switch (unit) {
      case "\n":
        yield { kind: "newline" };
        pos++;
        break;
      case "\r":
        if (text[pos + 1] === "\n") {
          yield { kind: "newline" };
          pos += 2;
        } else {
          yield { kind: "carriage-return" };
          pos += 1;
        }
        break;
      case "	":
        yield { kind: "tab" };
        pos++;
        break;
      case "\x1B":
        let valid = false;
        let newColumn;
        const escapeStart = pos;
        pos++;
        switch (text[pos]) {
          case "[":
            pos++;
            while (text[pos] >= "0" && text[pos] <= "?") {
              pos++;
            }
            if (text[pos] >= "\0x40" && text[pos] <= "~") {
              const param = text.slice(escapeStart + 2, pos);
              switch (text[pos]) {
                case "m":
                  yield {
                    kind: "style",
                    style: Style(param)
                  };
                  pos++;
                  continue;
                case "E":
                // Move up
                case "F":
                  newColumn = 0;
                  break;
                case "G":
                  newColumn = Number.parseInt(param);
                  break;
                case "H":
                  const [, column] = param.split(";");
                  newColumn = column ? Number.parseInt(column) : 0;
                  break;
                case "J":
                  switch (param) {
                    case "2":
                    // Entire screen
                    case "3":
                      newColumn = 0;
                  }
                  break;
              }
              pos++;
              valid = true;
            }
            break;
          case "X":
          case "]":
          case "^":
          case "_":
            pos++;
            while (pos < text.length) {
              pos++;
              if (text[pos] === "\\") {
                valid = true;
                break;
              }
            }
            break;
          default:
            const code = text[pos];
            if (code >= "@" && code <= "W" || code >= "Y" && code <= "Z" || code >= "\\" && code <= "]") {
              pos++;
              valid = true;
            } else if (code >= "0" && code <= "0x3f") {
              pos++;
              valid = true;
            } else if (code >= "`" && code <= "0x7e") {
              pos++;
              valid = true;
            } else if (code >= " " && code <= "0x2f") {
              pos++;
              const code2 = text[pos];
              if (code2 >= "0" && code2 <= "0x73") {
                pos++;
                valid = true;
              }
            }
            break;
        }
        if (valid) {
          const token = {
            kind: "ansi",
            sequence: text.slice(escapeStart, pos)
          };
          if (newColumn !== void 0 && !Number.isNaN(newColumn)) {
            token.newColumn = newColumn;
          }
          yield token;
        }
        break;
      default:
        const start = pos;
        if (Chars.breakingSpace.has(unit)) {
          let width2 = 1;
          pos++;
          while (Chars.breakingSpace.has(text[pos])) {
            pos++;
            if (unit !== "\u200B") {
              width2++;
            }
          }
          yield {
            kind: "breaking",
            str: text.slice(start, pos),
            width: width2
          };
          break;
        }
        let width = 0;
        while (pos < text.length) {
          let cp = text[pos];
          if (cp >= "\uD800" && cp < "\uDC00") {
            const nextUnit = text[pos + 1];
            if (nextUnit !== void 0 && nextUnit >= "\uDC00" && nextUnit < "\uE000") {
              cp += nextUnit;
            }
          }
          if (!cp.match(Chars.nonbreakingText)) {
            break;
          }
          pos += cp.length;
          if (!cp.match(Chars.zeroWidth)) {
            width++;
          }
        }
        if (start === pos) {
          pos++;
          break;
        }
        yield {
          kind: "nonbreaking",
          str: text.slice(start, pos),
          width
        };
    }
  }
}
export {
  tokenize
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vc3JjL2Fuc2ktdGV4dC90b2tlbml6ZS50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjItMjAyNSBNYXR0ZXIuanMgQXV0aG9yc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQgeyBDaGFycyB9IGZyb20gXCIuL2NoYXJzLmpzXCI7XG5pbXBvcnQgeyBQcm9kdWNlciB9IGZyb20gXCIuL3Byb2R1Y2VyLmpzXCI7XG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gXCIuL3N0eWxlLmpzXCI7XG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gXCIuL3Rva2VuLmpzXCI7XG5cbi8qKlxuICogQ29udmVydCBBTlNJIHRleHQgaW50byBhIHNlcXVlbmNlIG9mIHRva2Vucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiB0b2tlbml6ZSh0ZXh0OiBzdHJpbmcpOiBQcm9kdWNlciB7XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgdGV4dC5sZW5ndGg7ICkge1xuICAgICAgICBjb25zdCB1bml0ID0gdGV4dFtwb3NdO1xuICAgICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgICAgICB5aWVsZCB7IGtpbmQ6IFwibmV3bGluZVwiIH07XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgICAgICBpZiAodGV4dFtwb3MgKyAxXSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB7IGtpbmQ6IFwibmV3bGluZVwiIH07XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHsga2luZDogXCJjYXJyaWFnZS1yZXR1cm5cIiB9O1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJcXHRcIjpcbiAgICAgICAgICAgICAgICB5aWVsZCB7IGtpbmQ6IFwidGFiXCIgfTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIlxceDFiXCI6XG4gICAgICAgICAgICAgICAgbGV0IHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0NvbHVtbjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZVN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGV4dFtwb3NdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGZSBDU0lcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZCBzZXF1ZW5jZSBtZW1iZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGV4dFtwb3NdID49IFwiXFx4MzBcIiAmJiB0ZXh0W3Bvc10gPD0gXCJcXHgzZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkIHNlcXVlbmNlIHRlcm1pbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dFtwb3NdID49IFwiXFwweDQwXCIgJiYgdGV4dFtwb3NdIDw9IFwiXFx4N2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gdGV4dC5zbGljZShlc2NhcGVTdGFydCArIDIsIHBvcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHRbcG9zXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibVwiOiAvLyBTR1IgKHNlbGVjdCBncmFwaGljcyByZW5kaXRpb24pLCB0aGUgc2VxdWVuY2UgdGhhdCBjb250cm9scyBzdHlsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzdHlsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBTdHlsZShwYXJhbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRVwiOiAvLyBNb3ZlIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJGXCI6IC8vIE1vdmUgZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJHXCI6IC8vIE1vdmUgdG8gY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2x1bW4gPSBOdW1iZXIucGFyc2VJbnQocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjogLy8gTW92ZSB0byByb3cgYW5kIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgY29sdW1uXSA9IHBhcmFtLnNwbGl0KFwiO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbHVtbiA9IGNvbHVtbiA/IE51bWJlci5wYXJzZUludChjb2x1bW4pIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJKXCI6IC8vIENsZWFyIHNjcmVlbiBwYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjJcIjogLy8gRW50aXJlIHNjcmVlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIzXCI6IC8vIEVudGlyZSBzY3JlZW4gcGx1cyBzY3JvbGxiYWNrIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIl1cIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIl9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZlIHNlcXVlbmNlcyB0aGF0IHRha2UgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50ICg8RVNDIFg+LCA8RVNDIF0+LCA8RVNDIF4+LCA8RVNDIF8+XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXJtaW5hdGVkIGJ5IFwiXFxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRbcG9zXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHRleHRbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSBcIlxceDQwXCIgJiYgY29kZSA8PSBcIlxceDU3XCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gXCJcXHg1OVwiICYmIGNvZGUgPD0gXCJcXHg1YVwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb2RlID49IFwiXFx4NWNcIiAmJiBjb2RlIDw9IFwiXFx4NWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZlIHNlcXVlbmNlIG5vdCBjb3ZlcmVkIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID49IFwiXFx4MzBcIiAmJiBjb2RlIDw9IFwiMHgzZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnAgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPj0gXCJcXHg2MFwiICYmIGNvZGUgPD0gXCIweDdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGcyBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA+PSBcIlxceDIwXCIgJiYgY29kZSA8PSBcIjB4MmZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUyID0gdGV4dFtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlMiA+PSBcIlxceDMwXCIgJiYgY29kZTIgPD0gXCIweDczXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW46IFRva2VuID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJhbnNpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZTogdGV4dC5zbGljZShlc2NhcGVTdGFydCwgcG9zKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbHVtbiAhPT0gdW5kZWZpbmVkICYmICFOdW1iZXIuaXNOYU4obmV3Q29sdW1uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubmV3Q29sdW1uID0gbmV3Q29sdW1uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRva2VuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcG9zO1xuXG4gICAgICAgICAgICAgICAgLy8gV2hpdGVzcGFjZSAtIG5vIHN1cnJvZ2F0ZXMsIHplcm8td2lkdGggc3BhY2UgZG9lcyBub3QgY29udHJpYnV0ZSB0byB3aWR0aFxuICAgICAgICAgICAgICAgIGlmIChDaGFycy5icmVha2luZ1NwYWNlLmhhcyh1bml0KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKENoYXJzLmJyZWFraW5nU3BhY2UuaGFzKHRleHRbcG9zXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gd2lkdGggZm9yIHplcm8td2lkdGggc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bml0ICE9PSBcIlxcdTIwMGJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJicmVha2luZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyOiB0ZXh0LnNsaWNlKHN0YXJ0LCBwb3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNjYW4gY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjcCA9IHRleHRbcG9zXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHByb3BlciBzdXJyb2dhdGUgcGFpcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNwID49IFwiXFx1ZDgwMFwiICYmIGNwIDwgXCJcXHVkYzAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRVbml0ID0gdGV4dFtwb3MgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VW5pdCAhPT0gdW5kZWZpbmVkICYmIG5leHRVbml0ID49IFwiXFx1ZGMwMFwiICYmIG5leHRVbml0IDwgXCJcXHVlMDAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcCArPSBuZXh0VW5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3AubWF0Y2goQ2hhcnMubm9uYnJlYWtpbmdUZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gY3AubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNwLm1hdGNoKENoYXJzLnplcm9XaWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkZXRlY3RlZCBubyBjaGFyYWN0ZXJzLCB0aGUgY29kZSB1bml0IGlzIGdhcmJhZ2UgYW5kIHdlIHNraXAgaXQgZW50aXJlbHlcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gWWllbGQgdGhlIHRva2VuIGFuZCBza2lwIGZvcndhcmQgdG8gdGhlIGxhc3QgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBcIm5vbmJyZWFraW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0cjogdGV4dC5zbGljZShzdGFydCwgcG9zKSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQSxTQUFTLGFBQWE7QUFFdEIsU0FBUyxhQUFhO0FBTWYsVUFBVSxTQUFTLE1BQXdCO0FBQzlDLFdBQVMsTUFBTSxHQUFHLE1BQU0sS0FBSyxVQUFVO0FBQ25DLFVBQU0sT0FBTyxLQUFLLEdBQUc7QUFDckIsWUFBUSxNQUFNO0FBQUEsTUFDVixLQUFLO0FBQ0QsY0FBTSxFQUFFLE1BQU0sVUFBVTtBQUN4QjtBQUNBO0FBQUEsTUFFSixLQUFLO0FBQ0QsWUFBSSxLQUFLLE1BQU0sQ0FBQyxNQUFNLE1BQU07QUFDeEIsZ0JBQU0sRUFBRSxNQUFNLFVBQVU7QUFDeEIsaUJBQU87QUFBQSxRQUNYLE9BQU87QUFDSCxnQkFBTSxFQUFFLE1BQU0sa0JBQWtCO0FBQ2hDLGlCQUFPO0FBQUEsUUFDWDtBQUNBO0FBQUEsTUFFSixLQUFLO0FBQ0QsY0FBTSxFQUFFLE1BQU0sTUFBTTtBQUNwQjtBQUNBO0FBQUEsTUFFSixLQUFLO0FBQ0QsWUFBSSxRQUFRO0FBQ1osWUFBSTtBQUNKLGNBQU0sY0FBYztBQUNwQjtBQUNBLGdCQUFRLEtBQUssR0FBRyxHQUFHO0FBQUEsVUFDZixLQUFLO0FBRUQ7QUFHQSxtQkFBTyxLQUFLLEdBQUcsS0FBSyxPQUFVLEtBQUssR0FBRyxLQUFLLEtBQVE7QUFDL0M7QUFBQSxZQUNKO0FBR0EsZ0JBQUksS0FBSyxHQUFHLEtBQUssV0FBVyxLQUFLLEdBQUcsS0FBSyxLQUFRO0FBQzdDLG9CQUFNLFFBQVEsS0FBSyxNQUFNLGNBQWMsR0FBRyxHQUFHO0FBRTdDLHNCQUFRLEtBQUssR0FBRyxHQUFHO0FBQUEsZ0JBQ2YsS0FBSztBQUNELHdCQUFNO0FBQUEsb0JBQ0YsTUFBTTtBQUFBLG9CQUNOLE9BQU8sTUFBTSxLQUFLO0FBQUEsa0JBQ3RCO0FBQ0E7QUFDQTtBQUFBLGdCQUVKLEtBQUs7QUFBQTtBQUFB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
