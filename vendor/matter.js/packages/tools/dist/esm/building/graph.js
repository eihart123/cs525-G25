/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import colors from "ansi-colors";
import { JsonNotFoundError, Package } from "../util/package.js";
import { Progress } from "../util/progress.js";
import { InternalBuildError } from "./error.js";
import { BUILD_INFO_LOCATION, Project } from "./project.js";
class Graph {
  constructor(nodes) {
    this.nodes = nodes;
  }
  get(name) {
    const node = this.nodes.find((node2) => node2.pkg.name === name);
    if (node === void 0) {
      throw new Error(`Cannot locate package "${name}"`);
    }
    return node;
  }
  static async load(pkg = Package.workspace) {
    const nodeMap = await this.#loadNodes(pkg.workspace);
    return await this.#createGraph(Object.values(nodeMap));
  }
  static async forProject(path) {
    let workspace;
    try {
      workspace = Package.workspaceFor(path);
    } catch (e) {
      if (e instanceof JsonNotFoundError) {
        return;
      }
      throw e;
    }
    const nodeMap = await this.#loadNodes(workspace);
    const rootPkg = new Package({ path });
    const rootNode = nodeMap[rootPkg.json.name];
    if (!rootNode) {
      return;
    }
    const nodes = /* @__PURE__ */ new Set();
    function addNode(node) {
      if (nodes.has(node)) {
        return;
      }
      nodes.add(node);
      for (const dependency of node.dependencies) {
        addNode(dependency);
      }
    }
    addNode(rootNode);
    return await this.#createGraph([...nodes]);
  }
  // TODO - parallelization will be trivial except need to update Progress to support display of multiple simultaneous
  // tasks
  async build(builder, showSkipped = true) {
    const toBuild = new Set(this.nodes);
    const needsConfig = this.nodes.find((node) => node.pkg.hasConfig);
    if (builder.hasClean || needsConfig) {
      try {
        if (builder.hasClean) {
          builder.clearClean();
          for (const node of this.nodes) {
            await node.project.clean();
            node.info = {};
          }
        }
        for (const node of this.nodes) {
          if (!node.pkg.hasConfig) {
            continue;
          }
          await builder.configure(node.project);
        }
      } catch (e) {
        console.error("Terminating due to prebuild error:", e);
        process.exit(1);
      }
    }
    while (toBuild.size) {
      let node;
      nodes: for (node of toBuild) {
        for (const dep of node.dependencies) {
          if (dep.isDirty) {
            continue nodes;
          }
        }
        break;
      }
      if (!node) {
        throw new Error("Internal logic error: No unbuilt project has fully built dependencies");
      }
      if (node.isDirty || builder.unconditional) {
        await builder.build(node.project);
        node.info.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      } else if (showSkipped) {
        new Progress().skip("Up to date", node.pkg);
      }
      toBuild.delete(node);
    }
  }
  display() {
    for (const node of this.nodes) {
      const progress = node.pkg.start("Node");
      progress.info("path", node.pkg.path);
      progress.info("modified", formatTime(node.modifyTime));
      progress.info("built", formatTime(node.info.timestamp ?? 0));
      progress.info("dirty", node.isDirty ? colors.dim.red("yes") : colors.dim.green("no"));
      progress.info("dependencies", node.dependencies.map(formatDep).join(", "));
      progress.close();
    }
  }
  static async #createGraph(nodes) {
    const graph = new Graph(nodes);
    await Promise.all(
      graph.nodes.map(async (node) => {
        if (node.pkg.hasFile(BUILD_INFO_LOCATION)) {
          node.info = await node.pkg.readJson(BUILD_INFO_LOCATION);
        }
        node.modifyTime = await node.pkg.lastModified("package.json", "src", "test");
        return node;
      })
    );
    const stack = Array();
    function findCircular(node) {
      if (stack.indexOf(node) !== -1) {
        stack.push(node);
        throw new InternalBuildError(`Circular dependency: ${stack.map(formatDep).join(" \u25B8 ")}`);
      }
      stack.push(node);
      for (const dep of node.dependencies) {
        findCircular(dep);
      }
      stack.pop();
    }
    for (const node of graph.nodes) {
      findCircular(node);
    }
    return graph;
  }
  static async #loadNodes(workspace) {
    const workspaces = workspace.json.workspaces;
    const nodeMap = {};
    const allDeps = {};
    for (const path of workspaces.values()) {
      const pkg = new Package({ path: workspace.resolve(path) });
      allDeps[pkg.json.name] = pkg.dependencies;
      nodeMap[pkg.json.name] = {
        pkg,
        project: new Project(pkg),
        dependencies: [],
        info: {},
        modifyTime: 0,
        get buildTime() {
          return this.info.timestamp ? new Date(this.info.timestamp).getTime() : 0;
        },
        get isDirty() {
          return this.modifyTime > this.buildTime || !!this.dependencies.find(
            (dep) => dep.isDirty || dep.buildTime > this.buildTime && (dep.info.apiSha === void 0 || dep.info.apiSha !== this.info.dependencyApiShas?.[dep.pkg.name])
          );
        }
      };
    }
    for (const name in allDeps) {
      for (const dep of allDeps[name]) {
        const depNode = nodeMap[dep];
        if (depNode && depNode !== nodeMap[name]) {
          nodeMap[name].dependencies.push(depNode);
        }
      }
    }
    return nodeMap;
  }
}
function formatTime(time) {
  if (!time) {
    return colors.dim.red("never");
  }
  if (typeof time === "string") {
    time = new Date(time).getTime();
  }
  return new Date(time - (/* @__PURE__ */ new Date()).getTimezoneOffset()).toISOString().split(".")[0].replace("T", " ");
}
function formatDep(node) {
  return node.pkg.name.replace(/^@matter\//, "");
}
export {
  Graph
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vc3JjL2J1aWxkaW5nL2dyYXBoLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMi0yMDI1IE1hdHRlci5qcyBBdXRob3JzXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCBjb2xvcnMgZnJvbSBcImFuc2ktY29sb3JzXCI7XG5pbXBvcnQgeyBKc29uTm90Rm91bmRFcnJvciwgUGFja2FnZSB9IGZyb20gXCIuLi91dGlsL3BhY2thZ2UuanNcIjtcbmltcG9ydCB7IFByb2dyZXNzIH0gZnJvbSBcIi4uL3V0aWwvcHJvZ3Jlc3MuanNcIjtcbmltcG9ydCB7IEludGVybmFsQnVpbGRFcnJvciB9IGZyb20gXCIuL2Vycm9yLmpzXCI7XG5pbXBvcnQgeyBQcm9qZWN0QnVpbGRlciB9IGZyb20gXCIuL3Byb2plY3QtYnVpbGRlci5qc1wiO1xuaW1wb3J0IHsgQlVJTERfSU5GT19MT0NBVElPTiwgQnVpbGRJbmZvcm1hdGlvbiwgUHJvamVjdCB9IGZyb20gXCIuL3Byb2plY3QuanNcIjtcblxuLyoqXG4gKiBHcmFwaCBvZiBkZXBlbmRlbmNpZXMgZm9yIHdvcmtzcGFjZSBwYWNrYWdlcy5cbiAqXG4gKiBXZSB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggcGFja2FnZXMgYXJlIFwiZGlydHlcIiBhbmQgbmVlZCByZWJ1aWxkLiAgSW4gdGhlIGZ1dHVyZSB3ZSBjYW4gYWxzbyB1c2UgZm9yXG4gKiBwYXJhbGxlbCBidWlsZCwgb25seSB0cmlja3kgcGFydCB0aGVyZSBpcyBzaG93aW5nIHN0YXR1cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEdyYXBoIHtcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IocmVhZG9ubHkgbm9kZXM6IEdyYXBoLk5vZGVbXSkge31cblxuICAgIGdldChuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZXMuZmluZChub2RlID0+IG5vZGUucGtnLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBsb2NhdGUgcGFja2FnZSBcIiR7bmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBsb2FkKHBrZyA9IFBhY2thZ2Uud29ya3NwYWNlKSB7XG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBhd2FpdCB0aGlzLiNsb2FkTm9kZXMocGtnLndvcmtzcGFjZSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjcmVhdGVHcmFwaChPYmplY3QudmFsdWVzKG5vZGVNYXApKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgZm9yUHJvamVjdChwYXRoOiBzdHJpbmcpOiBQcm9taXNlPEdyYXBoIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGxldCB3b3Jrc3BhY2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3b3Jrc3BhY2UgPSBQYWNrYWdlLndvcmtzcGFjZUZvcihwYXRoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBKc29uTm90Rm91bmRFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFByb2plY3QgaXMgbm90IGluIGEgd29ya3NwYWNlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBhd2FpdCB0aGlzLiNsb2FkTm9kZXMod29ya3NwYWNlKTtcblxuICAgICAgICBjb25zdCByb290UGtnID0gbmV3IFBhY2thZ2UoeyBwYXRoOiBwYXRoIH0pO1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IG5vZGVNYXBbcm9vdFBrZy5qc29uLm5hbWVdO1xuICAgICAgICBpZiAoIXJvb3ROb2RlKSB7XG4gICAgICAgICAgICAvLyBQcm9qZWN0IHJlc2lkZXMgdW5kZXIgYSB3b3Jrc3BhY2UgYnV0IGlzIG5vdCBwYXJ0IG9mIHRoZSB3b3Jrc3BhY2VcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGVzID0gbmV3IFNldDxHcmFwaC5Ob2RlPigpO1xuICAgICAgICBmdW5jdGlvbiBhZGROb2RlKG5vZGU6IEdyYXBoLk5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2Rlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlcy5hZGQobm9kZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2Ygbm9kZS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBhZGROb2RlKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWRkTm9kZShyb290Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NyZWF0ZUdyYXBoKFsuLi5ub2Rlc10pO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSBwYXJhbGxlbGl6YXRpb24gd2lsbCBiZSB0cml2aWFsIGV4Y2VwdCBuZWVkIHRvIHVwZGF0ZSBQcm9ncmVzcyB0byBzdXBwb3J0IGRpc3BsYXkgb2YgbXVsdGlwbGUgc2ltdWx0YW5lb3VzXG4gICAgLy8gdGFza3NcbiAgICBhc3luYyBidWlsZChidWlsZGVyOiBQcm9qZWN0QnVpbGRlciwgc2hvd1NraXBwZWQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHRvQnVpbGQgPSBuZXcgU2V0KHRoaXMubm9kZXMpO1xuXG4gICAgICAgIGNvbnN0IG5lZWRzQ29uZmlnID0gdGhpcy5ub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5wa2cuaGFzQ29uZmlnKTtcbiAgICAgICAgaWYgKGJ1aWxkZXIuaGFzQ2xlYW4gfHwgbmVlZHNDb25maWcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2xlYW4gYWxsIHBhY2thZ2VzIGJlZm9yZSBlbmdhZ2luZyB0eXBlc2NyaXB0IGJlY2F1c2Ugb3RoZXJ3aXNlIGl0IHNlZW1zIHRvIGdldCBjb25mdXNlZFxuICAgICAgICAgICAgICAgIGlmIChidWlsZGVyLmhhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuY2xlYXJDbGVhbigpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbm9kZS5wcm9qZWN0LmNsZWFuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlIGNvbmZpZ3VyZSBlYWNoIGJ1aWxkIGJlZm9yZSBidWlsZGluZyBzbyB0aGF0IGFueSBnZW5lcmF0ZWQgZmlsZXMgYXJlIGluIHBsYWNlIGJlZm9yZSB3ZSBpbml0aWF0ZSB0aGUgYnVpbGRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUucGtnLmhhc0NvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYnVpbGRlci5jb25maWd1cmUobm9kZS5wcm9qZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRlcm1pbmF0aW5nIGR1ZSB0byBwcmVidWlsZCBlcnJvcjpcIiwgZSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRvQnVpbGQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG5vZGU7XG5cbiAgICAgICAgICAgIG5vZGVzOiBmb3IgKG5vZGUgb2YgdG9CdWlsZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVwIG9mIG5vZGUuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXAuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbm9kZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGxvZ2ljIGVycm9yOiBObyB1bmJ1aWx0IHByb2plY3QgaGFzIGZ1bGx5IGJ1aWx0IGRlcGVuZGVuY2llc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmlzRGlydHkgfHwgYnVpbGRlci51bmNvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYnVpbGRlci5idWlsZChub2RlLnByb2plY3QpO1xuICAgICAgICAgICAgICAgIG5vZGUuaW5mby50aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3dTa2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgbmV3IFByb2dyZXNzKCkuc2tpcChcIlVwIHRvIGRhdGVcIiwgbm9kZS5wa2cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b0J1aWxkLmRlbGV0ZShub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IG5vZGUucGtnLnN0YXJ0KFwiTm9kZVwiKTtcbiAgICAgICAgICAgIHByb2dyZXNzLmluZm8oXCJwYXRoXCIsIG5vZGUucGtnLnBhdGgpO1xuICAgICAgICAgICAgcHJvZ3Jlc3MuaW5mbyhcIm1vZGlmaWVkXCIsIGZvcm1hdFRpbWUobm9kZS5tb2RpZnlUaW1lKSk7XG4gICAgICAgICAgICBwcm9ncmVzcy5pbmZvKFwiYnVpbHRcIiwgZm9ybWF0VGltZShub2RlLmluZm8udGltZXN0YW1wID8/IDApKTtcbiAgICAgICAgICAgIHByb2dyZXNzLmluZm8oXCJkaXJ0eVwiLCBub2RlLmlzRGlydHkgPyBjb2xvcnMuZGltLnJlZChcInllc1wiKSA6IGNvbG9ycy5kaW0uZ3JlZW4oXCJub1wiKSk7XG4gICAgICAgICAgICBwcm9ncmVzcy5pbmZvKFwiZGVwZW5kZW5jaWVzXCIsIG5vZGUuZGVwZW5kZW5jaWVzLm1hcChmb3JtYXREZXApLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICBwcm9ncmVzcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jICNjcmVhdGVHcmFwaChub2RlczogR3JhcGguTm9kZVtdKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKG5vZGVzKTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzLm1hcChhc3luYyBub2RlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wa2cuaGFzRmlsZShCVUlMRF9JTkZPX0xPQ0FUSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmluZm8gPSBhd2FpdCBub2RlLnBrZy5yZWFkSnNvbihCVUlMRF9JTkZPX0xPQ0FUSU9OKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlLm1vZGlmeVRpbWUgPSBhd2FpdCBub2RlLnBrZy5sYXN0TW9kaWZpZWQoXCJwYWNrYWdlLmpzb25cIiwgXCJzcmNcIiwgXCJ0ZXN0XCIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBzdGFjayA9IEFycmF5PEdyYXBoLk5vZGU+KCk7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRDaXJjdWxhcihub2RlOiBHcmFwaC5Ob2RlKSB7XG4gICAgICAgICAgICBpZiAoc3RhY2suaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnRlcm5hbEJ1aWxkRXJyb3IoYENpcmN1bGFyIGRlcGVuZGVuY3k6ICR7c3RhY2subWFwKGZvcm1hdERlcCkuam9pbihcIiBcdTI1QjggXCIpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwIG9mIG5vZGUuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgZmluZENpcmN1bGFyKGRlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JhcGgubm9kZXMpIHtcbiAgICAgICAgICAgIGZpbmRDaXJjdWxhcihub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgI2xvYWROb2Rlcyh3b3Jrc3BhY2U6IFBhY2thZ2UpIHtcbiAgICAgICAgY29uc3Qgd29ya3NwYWNlcyA9IHdvcmtzcGFjZS5qc29uLndvcmtzcGFjZXM7XG5cbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IHt9IGFzIFJlY29yZDxzdHJpbmcsIEdyYXBoLk5vZGU+O1xuICAgICAgICBjb25zdCBhbGxEZXBzID0ge30gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nW10+O1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2Ygd29ya3NwYWNlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgcGtnID0gbmV3IFBhY2thZ2UoeyBwYXRoOiB3b3Jrc3BhY2UucmVzb2x2ZShwYXRoKSB9KTtcbiAgICAgICAgICAgIGFsbERlcHNbcGtnLmpzb24ubmFtZV0gPSBwa2cuZGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgbm9kZU1hcFtwa2cuanNvbi5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBwa2csXG4gICAgICAgICAgICAgICAgcHJvamVjdDogbmV3IFByb2plY3QocGtnKSxcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IFtdLFxuICAgICAgICAgICAgICAgIGluZm86IHt9LFxuICAgICAgICAgICAgICAgIG1vZGlmeVRpbWU6IDAsXG5cbiAgICAgICAgICAgICAgICBnZXQgYnVpbGRUaW1lKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZvLnRpbWVzdGFtcCA/IG5ldyBEYXRlKHRoaXMuaW5mby50aW1lc3RhbXApLmdldFRpbWUoKSA6IDA7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGdldCBpc0RpcnR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUaW1lID4gdGhpcy5idWlsZFRpbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICEhdGhpcy5kZXBlbmRlbmNpZXMuZmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXAgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwLmlzRGlydHkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlcC5idWlsZFRpbWUgPiB0aGlzLmJ1aWxkVGltZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlcC5pbmZvLmFwaVNoYSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwLmluZm8uYXBpU2hhICE9PSB0aGlzLmluZm8uZGVwZW5kZW5jeUFwaVNoYXM/LltkZXAucGtnLm5hbWVdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gYWxsRGVwcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXAgb2YgYWxsRGVwc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlcE5vZGUgPSBub2RlTWFwW2RlcF07XG5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIC0tIGFsbG93IG5vZGVzIHRvIHJlZmVyZW5jZSB0aGVtc2VsdmVzLCBzZWVtcyB0byBiZSBuZWNlc3Nhcnkgb24gdG9vbHMgZm9yIHVzZSBvZiB0c2NcbiAgICAgICAgICAgICAgICBpZiAoZGVwTm9kZSAmJiBkZXBOb2RlICE9PSBub2RlTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVNYXBbbmFtZV0uZGVwZW5kZW5jaWVzLnB1c2goZGVwTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGVNYXA7XG4gICAgfVxufVxuXG5leHBvcnQgbmFtZXNwYWNlIEdyYXBoIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIE5vZGUge1xuICAgICAgICBwa2c6IFBhY2thZ2U7XG4gICAgICAgIHByb2plY3Q6IFByb2plY3Q7XG4gICAgICAgIGRlcGVuZGVuY2llczogTm9kZVtdO1xuICAgICAgICBidWlsZFRpbWU6IG51bWJlcjtcbiAgICAgICAgaW5mbzogQnVpbGRJbmZvcm1hdGlvbjtcbiAgICAgICAgbW9kaWZ5VGltZTogbnVtYmVyO1xuICAgICAgICBpc0RpcnR5OiBib29sZWFuO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0VGltZSh0aW1lOiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9ycy5kaW0ucmVkKFwibmV2ZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGltZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aW1lID0gbmV3IERhdGUodGltZSkuZ2V0VGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUodGltZSAtIG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSkudG9JU09TdHJpbmcoKS5zcGxpdChcIi5cIilbMF0ucmVwbGFjZShcIlRcIiwgXCIgXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREZXAobm9kZTogR3JhcGguTm9kZSkge1xuICAgIHJldHVybiBub2RlLnBrZy5uYW1lLnJlcGxhY2UoL15AbWF0dGVyXFwvLywgXCJcIik7XG59XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUEsT0FBTyxZQUFZO0FBQ25CLFNBQVMsbUJBQW1CLGVBQWU7QUFDM0MsU0FBUyxnQkFBZ0I7QUFDekIsU0FBUywwQkFBMEI7QUFFbkMsU0FBUyxxQkFBdUMsZUFBZTtBQVF4RCxNQUFNLE1BQU07QUFBQSxFQUNMLFlBQXFCLE9BQXFCO0FBQXJCO0FBQUEsRUFBc0I7QUFBQSxFQUVyRCxJQUFJLE1BQWM7QUFDZCxVQUFNLE9BQU8sS0FBSyxNQUFNLEtBQUssQ0FBQUEsVUFBUUEsTUFBSyxJQUFJLFNBQVMsSUFBSTtBQUMzRCxRQUFJLFNBQVMsUUFBVztBQUNwQixZQUFNLElBQUksTUFBTSwwQkFBMEIsSUFBSSxHQUFHO0FBQUEsSUFDckQ7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsYUFBYSxLQUFLLE1BQU0sUUFBUSxXQUFXO0FBQ3ZDLFVBQU0sVUFBVSxNQUFNLEtBQUssV0FBVyxJQUFJLFNBQVM7QUFDbkQsV0FBTyxNQUFNLEtBQUssYUFBYSxPQUFPLE9BQU8sT0FBTyxDQUFDO0FBQUEsRUFDekQ7QUFBQSxFQUVBLGFBQWEsV0FBVyxNQUEwQztBQUM5RCxRQUFJO0FBQ0osUUFBSTtBQUNBLGtCQUFZLFFBQVEsYUFBYSxJQUFJO0FBQUEsSUFDekMsU0FBUyxHQUFHO0FBQ1IsVUFBSSxhQUFhLG1CQUFtQjtBQUVoQztBQUFBLE1BQ0o7QUFDQSxZQUFNO0FBQUEsSUFDVjtBQUVBLFVBQU0sVUFBVSxNQUFNLEtBQUssV0FBVyxTQUFTO0FBRS9DLFVBQU0sVUFBVSxJQUFJLFFBQVEsRUFBRSxLQUFXLENBQUM7QUFDMUMsVUFBTSxXQUFXLFFBQVEsUUFBUSxLQUFLLElBQUk7QUFDMUMsUUFBSSxDQUFDLFVBQVU7QUFFWDtBQUFBLElBQ0o7QUFFQSxVQUFNLFFBQVEsb0JBQUksSUFBZ0I7QUFDbEMsYUFBUyxRQUFRLE1BQWtCO0FBQy9CLFVBQUksTUFBTSxJQUFJLElBQUksR0FBRztBQUNqQjtBQUFBLE1BQ0o7QUFDQSxZQUFNLElBQUksSUFBSTtBQUNkLGlCQUFXLGNBQWMsS0FBSyxjQUFjO0FBQ3hDLGdCQUFRLFVBQVU7QUFBQSxNQUN0QjtBQUFBLElBQ0o7QUFFQSxZQUFRLFFBQVE7QUFFaEIsV0FBTyxNQUFNLEtBQUssYUFBYSxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQUEsRUFDN0M7QUFBQTtBQUFBO0FBQUEsRUFJQSxNQUFNLE1BQU0sU0FBeUIsY0FBYyxNQUFNO0FBQ3JELFVBQU0sVUFBVSxJQUFJLElBQUksS0FBSyxLQUFLO0FBRWxDLFVBQU0sY0FBYyxLQUFLLE1BQU0sS0FBSyxVQUFRLEtBQUssSUFBSSxTQUFTO0FBQzlELFFBQUksUUFBUSxZQUFZLGFBQWE7QUFDakMsVUFBSTtBQUVBLFlBQUksUUFBUSxVQUFVO0FBQ2xCLGtCQUFRLFdBQVc7QUFDbkIscUJBQVcsUUFBUSxLQUFLLE9BQU87QUFDM0Isa0JBQU0sS0FBSyxRQUFRLE1BQU07QUFDekIsaUJBQUssT0FBTyxDQUFDO0FBQUEsVUFDakI7QUFBQSxRQUNKO0FBR0EsbUJBQVcsUUFBUSxLQUFLLE9BQU87QUFDM0IsY0FBSSxDQUFDLEtBQUssSUFBSSxXQUFXO0FBQ3JCO0FBQUEsVUFDSjtBQUNBLGdCQUFNLFFBQVEsVUFBVSxLQUFLLE9BQU87QUFBQSxRQUN4QztBQUFBLE1BQ0osU0FBUyxHQUFHO0FBQ1IsZ0JBQVEsTUFBTSxzQ0FBc0MsQ0FBQztBQUNyRCxnQkFBUSxLQUFLLENBQUM7QUFBQSxNQUNsQjtBQUFBLElBQ0o7QUFFQSxXQUFPLFFBQVEsTUFBTTtBQUNqQixVQUFJO0FBRUosWUFBTyxNQUFLLFFBQVEsU0FBUztBQUN6QixtQkFBVyxPQUFPLEtBQUssY0FBYztBQUNqQyxjQUFJLElBQUksU0FBUztBQUNiLHFCQUFTO0FBQUEsVUFDYjtBQUFBLFFBQ0o7QUFDQTtBQUFBLE1BQ0o7QUFFQSxVQUFJLENBQUMsTUFBTTtBQUNQLGNBQU0sSUFBSSxNQUFNLHVFQUF1RTtBQUFBLE1BQzNGO0FBQ0EsVUFBSSxLQUFLLFdBQVcsUUFBUSxlQUFlO0FBQ3ZDLGNBQU0sUUFBUSxNQUFNLEtBQUssT0FBTztBQUNoQyxhQUFLLEtBQUssYUFBWSxvQkFBSSxLQUFLLEdBQUUsWUFBWTtBQUFBLE1BQ2pELFdBQVcsYUFBYTtBQUNwQixZQUFJLFNBQVMsRUFBRSxLQUFLLGNBQWMsS0FBSyxHQUFHO0FBQUEsTUFDOUM7QUFFQSxjQUFRLE9BQU8sSUFBSTtBQUFBLElBQ3ZCO0FBQUEsRUFDSjtBQUFBLEVBRUEsVUFBVTtBQUNOLGVBQVcsUUFBUSxLQUFLLE9BQU87QUFDM0IsWUFBTSxXQUFXLEtBQUssSUFBSSxNQUFNLE1BQU07QUFDdEMsZUFBUyxLQUFLLFFBQVEsS0FBSyxJQUFJLElBQUk7QUFDbkMsZUFBUyxLQUFLLFlBQVksV0FBVyxLQUFLLFVBQVUsQ0FBQztBQUNyRCxlQUFTLEtBQUssU0FBUyxXQUFXLEtBQUssS0FBSyxhQUFhLENBQUMsQ0FBQztBQUMzRCxlQUFTLEtBQUssU0FBUyxLQUFLLFVBQVUsT0FBTyxJQUFJLElBQUksS0FBSyxJQUFJLE9BQU8sSUFBSSxNQUFNLElBQUksQ0FBQztBQUNwRixlQUFTLEtBQUssZ0JBQWdCLEtBQUssYUFBYSxJQUFJLFNBQVMsRUFBRSxLQUFLLElBQUksQ0FBQztBQUN6RSxlQUFTLE1BQU07QUFBQSxJQUNuQjtBQUFBLEVBQ0o7QUFBQSxFQUVBLGFBQWEsYUFBYSxPQUFxQjtBQUMzQyxVQUFNLFFBQVEsSUFBSSxNQUFNLEtBQUs7QUFFN0IsVUFBTSxRQUFRO0FBQUEsTUFDVixNQUFNLE1BQU0sSUFBSSxPQUFNLFNBQVE7QUFDMUIsWUFBSSxLQUFLLElBQUksUUFBUSxtQkFBbUIsR0FBRztBQUN2QyxlQUFLLE9BQU8sTUFBTSxLQUFLLElBQUksU0FBUyxtQkFBbUI7QUFBQSxRQUMzRDtBQUVBLGFBQUssYUFBYSxNQUFNLEtBQUssSUFBSSxhQUFhLGdCQUFnQixPQUFPLE1BQU07QUFFM0UsZUFBTztBQUFBLE1BQ1gsQ0FBQztBQUFBLElBQ0w7QUFFQSxVQUFNLFFBQVEsTUFBa0I7QUFDaEMsYUFBUyxhQUFhLE1BQWtCO0FBQ3BDLFVBQUksTUFBTSxRQUFRLElBQUksTUFBTSxJQUFJO0FBQzVCLGNBQU0sS0FBSyxJQUFJO0FBQ2YsY0FBTSxJQUFJLG1CQUFtQix3QkFBd0IsTUFBTSxJQUFJLFNBQVMsRUFBRSxLQUFLLFVBQUssQ0FBQyxFQUFFO0FBQUEsTUFDM0Y7QUFDQSxZQUFNLEtBQUssSUFBSTtBQUNmLGlCQUFXLE9BQU8sS0FBSyxjQUFjO0FBQ2pDLHFCQUFhLEdBQUc7QUFBQSxNQUNwQjtBQUNBLFlBQU0sSUFBSTtBQUFBLElBQ2Q7QUFDQSxlQUFXLFFBQVEsTUFBTSxPQUFPO0FBQzVCLG1CQUFhLElBQUk7QUFBQSxJQUNyQjtBQUVBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFQSxhQUFhLFdBQVcsV0FBb0I7QUFDeEMsVUFBTSxhQUFhLFVBQVUsS0FBSztBQUVsQyxVQUFNLFVBQVUsQ0FBQztBQUNqQixVQUFNLFVBQVUsQ0FBQztBQUNqQixlQUFXLFFBQVEsV0FBVyxPQUFPLEdBQUc7QUFDcEMsWUFBTSxNQUFNLElBQUksUUFBUSxFQUFFLE1BQU0sVUFBVSxRQUFRLElBQUksRUFBRSxDQUFDO0FBQ3pELGNBQVEsSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJO0FBQzdCLGNBQVEsSUFBSSxLQUFLLElBQUksSUFBSTtBQUFBLFFBQ3JCO0FBQUEsUUFDQSxTQUFTLElBQUksUUFBUSxHQUFHO0FBQUEsUUFDeEIsY0FBYyxDQUFDO0FBQUEsUUFDZixNQUFNLENBQUM7QUFBQSxRQUNQLFlBQVk7QUFBQSxRQUVaLElBQUksWUFBWTtBQUNaLGlCQUFPLEtBQUssS0FBSyxZQUFZLElBQUksS0FBSyxLQUFLLEtBQUssU0FBUyxFQUFFLFFBQVEsSUFBSTtBQUFBLFFBQzNFO0FBQUEsUUFFQSxJQUFJLFVBQVU7QUFDVixpQkFDSSxLQUFLLGFBQWEsS0FBSyxhQUN2QixDQUFDLENBQUMsS0FBSyxhQUFhO0FBQUEsWUFDaEIsU0FDSSxJQUFJLFdBQ0gsSUFBSSxZQUFZLEtBQUssY0FDakIsSUFBSSxLQUFLLFdBQVcsVUFDakIsSUFBSSxLQUFLLFdBQVcsS0FBSyxLQUFLLG9CQUFvQixJQUFJLElBQUksSUFBSTtBQUFBLFVBQzlFO0FBQUEsUUFFUjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsZUFBVyxRQUFRLFNBQVM7QUFDeEIsaUJBQVcsT0FBTyxRQUFRLElBQUksR0FBRztBQUM3QixjQUFNLFVBQVUsUUFBUSxHQUFHO0FBRzNCLFlBQUksV0FBVyxZQUFZLFFBQVEsSUFBSSxHQUFHO0FBQ3RDLGtCQUFRLElBQUksRUFBRSxhQUFhLEtBQUssT0FBTztBQUFBLFFBQzNDO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFFQSxXQUFPO0FBQUEsRUFDWDtBQUNKO0FBY0EsU0FBUyxXQUFXLE1BQXVCO0FBQ3ZDLE1BQUksQ0FBQyxNQUFNO0FBQ1AsV0FBTyxPQUFPLElBQUksSUFBSSxPQUFPO0FBQUEsRUFDakM7QUFDQSxNQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzFCLFdBQU8sSUFBSSxLQUFLLElBQUksRUFBRSxRQUFRO0FBQUEsRUFDbEM7QUFDQSxTQUFPLElBQUksS0FBSyxRQUFPLG9CQUFJLEtBQUssR0FBRSxrQkFBa0IsQ0FBQyxFQUFFLFlBQVksRUFBRSxNQUFNLEdBQUcsRUFBRSxDQUFDLEVBQUUsUUFBUSxLQUFLLEdBQUc7QUFDdkc7QUFFQSxTQUFTLFVBQVUsTUFBa0I7QUFDakMsU0FBTyxLQUFLLElBQUksS0FBSyxRQUFRLGNBQWMsRUFBRTtBQUNqRDsiLAogICJuYW1lcyI6IFsibm9kZSJdCn0K
